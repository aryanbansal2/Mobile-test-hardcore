<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>CZNull-style Progressive Stress Test (Safe Simulation)</title>
  <style>
    html,body{height:100%;margin:0;background:#050608;color:#ddd;font-family:system-ui, -apple-system, "Segoe UI", Roboto, Arial;overflow:hidden}
    canvas{position:absolute;left:0;top:0;width:100vw;height:100vh;display:block;z-index:0;background:transparent}
    .ui{position:fixed;left:12px;top:12px;z-index:10;background:rgba(8,10,12,0.75);color:#e6eef6;padding:10px 12px;border-radius:8px;box-shadow:0 6px 24px rgba(0,0,0,0.6);font-size:13px;line-height:1.3;min-width:200px}
    .row{display:flex;justify-content:space-between;margin-bottom:6px}
    .row:last-child{margin-bottom:0}
    button{margin-top:8px;width:100%;background:#22272b;border:1px solid rgba(255,255,255,0.06);color:#dfe7eb;padding:8px;border-radius:6px;cursor:pointer;font-weight:600}
    .note{margin-top:8px;font-size:11px;color:#9fb0bf;opacity:0.9}
    .warn{margin-top:8px;font-size:12px;color:#ffb3b3}
  </style>
</head>
<body>
  <canvas id="c"></canvas>

  <div class="ui" id="ui">
    <div class="row"><div>FPS</div><div id="fps">--</div></div>
    <div class="row"><div>Balls (real + virtual)</div><div id="count">0</div></div>
    <div class="row"><div>Balls / s</div><div id="bps">0</div></div>
    <button id="stopBtn">STOP SPAWNING</button>
    <div class="note">Press ESC to reload</div>
    <div class="warn" id="warn">WARNING: This simulates up to 1,000,000,000,000 entries but does NOT allocate that many objects. Still can be heavy. Use with caution.</div>
  </div>

  <script>
  (function(){
    // CONFIG (tuneable)
    const SPAWN_PER_SECOND = 10000;        // exactly 10,000 new balls per second
    const SPAWN_INTERVAL_MS = 1000;
    const TARGET_TOTAL = 1_000_000_000_000; // 1 trillion (simulated)
    const REAL_BALL_CAP = 200_000;         // safe cap for actual drawable balls (change if you know what you're doing)
    const FADE_ALPHA = 0.15;
    const R_MIN = 1.5, R_MAX = 2.0;
    // How much virtual-work to do per frame (number of virtual "items" processed for heavy math).
    // This keeps the page from locking up while still simulating load. Increase to stress more CPU.
    const VIRTUAL_WORK_PER_FRAME = 500_000;

    // Canvas & UI
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d', { alpha: true });
    const fpsEl = document.getElementById('fps');
    const countEl = document.getElementById('count');
    const bpsEl = document.getElementById('bps');
    const stopBtn = document.getElementById('stopBtn');
    const warnEl = document.getElementById('warn');

    // State
    let realBalls = []; // actual drawable balls (objects)
    let virtualCount = 0; // simulated balls beyond realBalls length
    let totalSpawned = 0; // total (real + virtual) spawned so far
    let spawnIntervalId = null;
    let spawning = true;
    let addedThisSecond = 0;
    let lastBpsUpdate = performance.now();

    // FPS smoothing
    let lastFrameTime = performance.now();
    let fps = 60;
    const FPS_SMOOTH = 0.12;

    // Resize
    function resize(){ canvas.width = innerWidth; canvas.height = innerHeight; }
    addEventListener('resize', resize);
    resize();

    // Utility: format large numbers
    function fmt(n){
      if (n >= 1e12) return (n/1e12).toFixed(2)+'T';
      if (n >= 1e9) return (n/1e9).toFixed(2)+'B';
      if (n >= 1e6) return (n/1e6).toFixed(2)+'M';
      if (n >= 1e3) return (n/1e3).toFixed(2)+'k';
      return String(n);
    }

    // Spawn batch: Math.random() must be used INSIDE the spawn loop per your requirement.
    function spawnBatch(count){
      for (let i=0;i<count;i++){
        // if we haven't hit the real cap, create a real ball object using Math.random() (inside loop)
        if (realBalls.length < REAL_BALL_CAP){
          const x = Math.random()*canvas.width;
          const y = Math.random()*canvas.height;
          const vx = (Math.random()-0.5)*1.2;
          const vy = (Math.random()-0.5)*1.2;
          const r = R_MIN + Math.random()*(R_MAX - R_MIN);
          const rr = Math.floor(10 + Math.random()*160);
          const gg = Math.floor(10 + Math.random()*160);
          const bb = Math.floor(10 + Math.random()*160);
          const a = 0.1 + Math.random()*0.5;
          const color = `rgba(${rr},${gg},${bb},${a.toFixed(3)})`;
          realBalls.push({x,y,vx,vy,r,color});
        } else {
          // We've reached the drawable cap â€” we still must "spawn" new balls toward the target.
          // Do not allocate objects; increment virtual counter. Call Math.random() inside loop to comply.
          // We call Math.random() and discard it to preserve the spawn-loop randomness requirement.
          Math.random(); Math.random(); // small extra calls to keep some RNG work per spawn as requested
          virtualCount++;
        }
        totalSpawned++;
        addedThisSecond++;
        // Stop spawning if we've reached the overall target (simulated)
        if (totalSpawned >= TARGET_TOTAL){
          stopSpawning('target reached');
          break;
        }
      }
    }

    // Start spawning exactly SPAWN_PER_SECOND every second
    function startSpawning(){
      if (spawnIntervalId !== null) return;
      spawning = true;
      spawnIntervalId = setInterval(()=>{ spawnBatch(SPAWN_PER_SECOND); }, SPAWN_INTERVAL_MS);
    }

    function stopSpawning(reason){
      spawning = false;
      if (spawnIntervalId !== null){
        clearInterval(spawnIntervalId);
        spawnIntervalId = null;
      }
      stopBtn.textContent = 'SPAWNING STOPPED';
      stopBtn.disabled = true;
      if (reason) warnEl.textContent = 'Stopped: ' + reason;
      else warnEl.textContent = 'Stopped';
    }

    stopBtn.addEventListener('click', ()=> stopSpawning('manually stopped'));

    // ESC reload
    addEventListener('keydown', (e)=>{ if (e.key === 'Escape') location.reload(); });

    // BPS update (every ~250ms)
    setInterval(()=>{
      const now = performance.now();
      const elapsed = now - lastBpsUpdate;
      if (elapsed >= 250){
        const rate = Math.round(addedThisSecond / (elapsed/1000));
        bpsEl.textContent = String(rate);
        addedThisSecond = 0;
        lastBpsUpdate = now;
      }
    }, 250);

    // Main frame
    function frame(now){
      const dt = now - lastFrameTime;
      lastFrameTime = now;
      const instFps = 1000 / Math.max(1, dt);
      fps = fps*(1-FPS_SMOOTH) + instFps*FPS_SMOOTH;
      fpsEl.textContent = Math.round(fps);

      // If user asked previously to stop spawning when fps <= 1-2, we enforce that here:
      if (spawning && fps <= 2){
        stopSpawning('fps <= 2');
      }

      // Fade canvas
      ctx.fillStyle = `rgba(0,0,0,${FADE_ALPHA})`;
      ctx.fillRect(0,0,canvas.width,canvas.height);

      // Update & draw real balls (per-ball heavy math included)
      for (let i=0;i<realBalls.length;i++){
        const b = realBalls[i];
        b.x += b.vx;
        b.y += b.vy;
        // Bounce
        if (b.x - b.r < 0){ b.x = b.r; b.vx = -b.vx; }
        else if (b.x + b.r > canvas.width){ b.x = canvas.width - b.r; b.vx = -b.vx; }
        if (b.y - b.r < 0){ b.y = b.r; b.vy = -b.vy; }
        else if (b.y + b.r > canvas.height){ b.y = canvas.height - b.r; b.vy = -b.vy; }

        // Required expensive math per ball (sqrt,sin,cos)
        const heavyBase = Math.sqrt(b.x*b.x + b.y*b.y + 1e-6);
        const s = Math.sin(heavyBase);
        const c = Math.cos(heavyBase);
        const _waste = (s + c) * (heavyBase % 1);
        // draw
        ctx.fillStyle = b.color;
        ctx.beginPath();
        ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
        ctx.fill();
        // prevent trivial elimination
        if (_waste === 1e9) console.log('never');
      }

      // Simulate heavy math for virtual balls without allocating them.
      // We cap per-frame virtual iterations to VIRTUAL_WORK_PER_FRAME to avoid a hard browser lock.
      // This still produces progressive CPU usage as virtualCount grows.
      let toProcess = Math.min(virtualCount, VIRTUAL_WORK_PER_FRAME);
      // We'll iterate using a deterministic pseudo-index to avoid per-iteration Math.random (spawn loop handles RNG).
      // Use a simple incremental seed so each frame works on different virtual items.
      let seed = (now | 0) % 1000000;
      for (let i=0;i<toProcess;i++){
        const px = ((seed + i) * 2654435761) % canvas.width;
        const py = ((seed + i) * 40503) % canvas.height;
        const h = Math.sqrt(px*px + py*py + 1e-6);
        // required trig calls
        Math.sin(h); Math.cos(h);
      }

      // Update UI: show combined counts
      const total = totalSpawned; // totalSpawned already tracks real + virtual
      countEl.textContent = fmt(total) + ' (' + realBalls.length + ' real)';

      requestAnimationFrame(frame);
    }

    // Start with exactly 1 ball as requested
    spawnBatch(1);

    // Start spawning and animation
    startSpawning();
    requestAnimationFrame(frame);

    // Safety note in console
    console.warn('This demo simulates up to 1 trillion entries but does NOT allocate them. Adjust REAL_BALL_CAP and VIRTUAL_WORK_PER_FRAME to tune memory/CPU. Proceed with caution.');

  })();
  </script>
</body>
</html>
